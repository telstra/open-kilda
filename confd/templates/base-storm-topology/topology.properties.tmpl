# Generated by confd.
# Do not change this file, all changes will be lost. Change corresponding template.

environment.naming.prefix = {{ getv "/kilda_environment_naming_prefix" }}

#######
# Storm-specific topology configuration.
#
# Configure timeout milliseconds used for disruptor queue wait strategy. Can be used to tradeoff latency vs. CPU usage.
{{- if exists "/kilda_storm_disruptor_wait_timeout" }}
disruptor.wait.timeout = {{ getv "/kilda_storm_disruptor_wait_timeout" }}
{{- else }}
# disruptor.wait.timeout =
{{- end }}
#
# The maximum age in milliseconds a batch can be before being sent to the next thread.
{{- if exists "/kilda_storm_disruptor_batch_timeout" }}
disruptor.batch.timeout = {{ getv "/kilda_storm_disruptor_batch_timeout" }}
{{- else }}
# disruptor.batch.timeout =
{{- end }}
#
# The amount of milliseconds a spout should sleep when emits no tuples.
{{- if exists "/kilda_storm_spout_wait_sleep_timeout" }}
spout.wait.sleep.time = {{ getv "/kilda_storm_spout_wait_sleep_timeout" }}
{{- else }}
# spout.wait.sleep.time =
{{- end }}

kafka.hosts = {{ getv "/kilda_kafka_hosts" }}
kafka.partitions.default = 1
kafka.replication.default = 3

reroute.throttling.delay.min = {{ getv "/kilda_reroute_throttling_delay_min" }}
reroute.throttling.delay.max = {{ getv "/kilda_reroute_throttling_delay_max" }}

isl.unstable.timeout.sec = {{ getv "/kilda_isl_unstable_timeout_sec" }}

port.up.down.throttling.delay.seconds.min = {{ getv "/kilda_port_up_down_throttling_delay_seconds_min" }}
port.up.down.throttling.delay.seconds.warm.up = {{ getv "/kilda_port_up_down_throttling_delay_seconds_warm_up" }}
port.up.down.throttling.delay.seconds.cool.down = {{ getv "/kilda_port_up_down_throttling_delay_seconds_cool_down" }}
port.antiflap.stats.dumping.interval.seconds = 60

lag.port.offset = {{ getv "/kilda_lag_port_offset" }}
lag.port.max.number = {{ getv "/kilda_lag_port_max_number" }}
lag.port.pool.chunks.count = 10
lag.port.pool.cache.size = 128
bfd.port.offset = {{ getv "/kilda_bfd_port_offset" }}
bfd.port.max.number = {{ getv "/kilda_bfd_port_max_number" }}

zookeeper.connect_string = {{ getv "/kilda_zookeeper_hosts"}}/{{ getv "/kilda_zookeeper_state_root" }}
zookeeper.reconnect_delay={{ getv "/kilda_zookeeper_reconnect_delay_ms"}}

persistence.implementation.default = {{ getv "/kilda_persistence_default_implementation" }}
persistence.implementation.area.history = {{ getv "/kilda_persistence_history_implementation" }}

opentsdb.hosts = http://{{ getv "/kilda_opentsdb_hosts" }}:{{ getv "/kilda_opentsdb_port" }}
opentsdb.timeout = {{ getv "/kilda_opentsdb_timeout" }}
opentsdb.batch.size = {{ getv "/kilda_opentsdb_batch_size" }}
opentsdb.flush.interval = {{ getv "/kilda_opentsdb_flush_interval" }}
opentsdb.client.chunked-requests.enabled = true
opentsdb.metric.prefix = {{ getv "/kilda_opentsdb_metric_prefix" }}

statistics.interval = {{ getv "/kilda_statistics_interval" }}

hibernate.user = {{ getv "/kilda_hibernate_user" }}
hibernate.password = {{ getv "/kilda_hibernate_password" }}
hibernate.url = {{ getv "/kilda_hibernate_url" }}
#hibernate.driver_class = com.mysql.jdbc.Driver

{{if not (exists "/single_orientdb")}}
orientdb.url=remote:{{ getv "/kilda_orientdb_hosts" }}/{{ getv "/kilda_orientdb_database" }}
{{else}}
orientdb.url=remote:{{ getv "/kilda_orientdb_hosts_single" }}/{{ getv "/kilda_orientdb_database" }}
{{end}}
orientdb.user = {{ getv "/kilda_orientdb_user" }}
orientdb.password = {{ getv "/kilda_orientdb_password" }}

logger.level = INFO

#######
# Discovery
# - discovery.generic.interval = how many bolt ticks(1 tick per second) between ISL discovery / health checks, starts from 0
# - discovery.exhausted.interval = how many seconds between sending a discovery packet in case
#   if the endpoint (switch + port) does not belong to ISL
# - discovery.auxiliary.interval = how many seconds between ISL discovery when another mechanism is used
#   to determine ISL state (e.g. BFD)
# - discovery.timeout = at which point do we send an ISL Failure (if it is an ISL)
#       - NB: the number is in "ticks", not "attempts" .. attempts = timeout/interval
# - discovery.limit = at what point do we stop sending? -1 means never ..
# - discovery.speaker-failure-timeout - after this amount of seconds without a
#   message from speaker it will be marked as unavailable
# - discovery.keep.removed.isl - how long should we store/remember in minutes isl endpoints.
#   it is mainly used for defining whether isl is moved or not
discovery.generic.interval = {{ getv "/kilda_discovery_generic_interval" }}
discovery.exhausted.interval = {{ getv "/kilda_discovery_exhausted_interval" }}
discovery.auxiliary.interval = {{ getv "/kilda_discovery_auxiliary_interval" }}
discovery.packet.ttl = {{ getv "/kilda_discovery_packet_ttl" }}
discovery.timeout = {{ getv "/kilda_discovery_timeout" }}
discovery.db.write.repeats.time.frame = {{ getv "/kilda_discovery_db_write_repeats_time_frame" }}

switch.offline.generation.lag = {{ getv "/kilda_network_switch_offline_generation_lag" }}

# multi-FL
floodlight.alive.timeout = {{ getv "/kilda_floodlight_alive_timeout" }}
floodlight.alive.interval = {{ getv "/kilda_floodlight_alive_interval" }}
floodlight.regions = {{ getv "/kilda_floodlight_regions" }}
# floodlight.switch.mapping.remove.delay.seconds = 900

local = no
local.execution.time = 3000

#######
# Path computation engine
pce.network.strategy = {{ getv "/kilda_pce_network_strategy" }}
pce.max.path.count = {{ getv "/kilda_pce_max_path_count" }}
#######
# cost strategy params
# value added to path weight for each isl used in the same diversity group
pce.diversity.isl.cost = {{ getv "/kilda_diversity_isl_cost" }}
# value added to path weight for each switch used in the same diversity group
pce.diversity.switch.cost = {{ getv "/kilda_diversity_switch_cost" }}
# value added to path weight for each ustable isl
pce.isl.cost.when.unstable = {{ getv "/kilda_isl_cost_when_unstable" }}
# value added to path weight for each isl under maintenance
pce.isl.cost.when.under.maintenance = {{ getv "/kilda_isl_cost_when_under_maintenance" }}
#######
# latency strategy params
# value added to path weight for each isl used in the same diversity group
pce.diversity.isl.latency = {{ getv "/kilda_diversity_isl_latency" }}
# value added to path weight for each switch used in the same diversity group
pce.diversity.switch.latency = {{ getv "/kilda_diversity_switch_latency" }}
# value added to path weight for each ustable isl
pce.isl.latency.when.unstable = {{ getv "/kilda_isl_latency_when_unstable" }}
# value added to path weight for each isl under maintenance
pce.isl.latency.when.under.maintenance = {{ getv "/kilda_isl_latency_when_under_maintenance" }}

burst.coefficient = {{ getv "/kilda_floodlight_flow_meter_burst_coefficient" }}
min.burst.size.in.kbits = 1024

# round trip latency
latency.update.interval = {{ getv "/kilda_latency_update_interval" }}
latency.update.time.range = {{ getv "/kilda_latency_update_time_range" }}
latency.discovery.interval.multiplier = {{ getv "/kilda_latency_discovery_interval_multiplier" }}

# flow(H&S) topology
flow.path.allocation.retries = 10
flow.path.allocation.retry.delay = 50
flow.create.hub.timeout.seconds = 30
flow.speaker.timeout.seconds = 10
flow.create.speaker.command.retries = {{ getv "/kilda_flow_create_command_retries" }}
flow.create.hub.retries = {{ getv "/kilda_flow_create_hub_retries" }}
flow.update.hub.timeout.seconds = 30
flow.update.speaker.command.retries = 3
flow.reroute.hub.timeout.seconds = 30
flow.reroute.speaker.command.retries = 3
flow.delete.hub.timeout.seconds = 30
flow.delete.speaker.command.retries = 3

blue.green.mode = {{ getv "/kilda_blue_green_mode" "blue" }}

# flow-monitoring topology
#
# flow.sla.check.shard.count parameter is needed to distribute load of Flow SLA
# check operation. Instead of checking of all flows ones in flow.sla.check.interval.seconds
# flows will be checked by chunks. That is why parameter flow.sla.check.interval.seconds
# must be divisible by flow.sla.check.shard.count
flow.sla.check.interval.seconds = {{ getv "/kilda_flow_sla_check_interval_seconds" }}
flow.sla.check.shard.count = {{ getv "/kilda_flow_sla_check_shard_count" }}
flow.rtt.stats.expiration.seconds = {{ getv "/kilda_flow_rtt_stats_expiration_seconds" }}
isl.rtt.latency.expiration.seconds = {{ getv "/kilda_isl_rtt_latency_expiration_seconds" }}
flow.latency.sla.timeout.seconds = {{ getv "/kilda_flow_latency_sla_timeout_seconds" }}
flow.latency.sla.threshold.percent = {{ getv "/kilda_flow_latency_sla_threshold_percent" }}

# rule-manager
flow-ping-magic-src-mac-address = {{ getv "/kilda_floodlight_flow_ping_magic_src_mac_address" }}
discovery-bcast-packet-dst = {{ getv "/kilda_floodlight_broadcast_mac_address" }}
server42-isl-rtt-magic-mac-address = {{ getv "/kilda_floodlight_server42_isl_rtt_magic_mac_address" }}

# swmanager
swmanager.of.commands.batch.size = {{ getv "/kilda_swmanager_of_commands_batch_size" }}
swmanager.kafka.chunked.messages.size = {{ getv "/kilda_swmanager_kafka_chunked_messages_size" }}

# Generated by confd.
# Do not change this file, all changes will be lost. Change corresponding template.
input {
  dead_letter_queue {
    path => "/usr/share/logstash/data/dead_letter_queue"
    tags => ["dead_letter_queue"]
  }
  tcp {
    port => {{ getv "/kilda_logging_port_storm" }}
    codec => json
    type => "kilda-storm"
    tags => ["storm-worker_log"]
  }
  tcp {
    port => {{ getv "/kilda_logging_port_grpc" }}
    codec => json
    type => "kilda-grpc"
    tags => ["kilda-grpc"]
  }
  tcp {
    port => {{ getv "/kilda_logging_port_floodlight" }}
    codec => json_lines
    type => "kilda-FL"
    tags => ["kilda-floodlight"]
  }
  tcp {
    port => {{ getv "/kilda_logging_port_lab_service" }}
    codec => json
    type => "kilda-lab-service"
    tags => ["kilda-lab-service"]
  }
  tcp {
    port => {{ getv "/kilda_logging_port_northbound" }}
    codec => json
    type => "kilda-NB"
    tags => ["kilda-northbound"]
  }
  tcp {
      port => {{ getv "/kilda_logging_port_server42_control" }}
      codec => json
      type => "kilda-server42-control"
      tags => ["kilda-server42"]
  }
  tcp {
      port => {{ getv "/kilda_logging_port_server42_control_server_stub" }}
      codec => json
      type => "kilda-server42-control-server-stub"
      tags => ["kilda-server42"]
  }
  tcp {
      port => {{ getv "/kilda_logging_port_server42_control_storm_stub" }}
      codec => json
      type => "kilda-server42-control-storm-stub"
      tags => ["kilda-server42"]
  }
  tcp {
      port => {{ getv "/kilda_logging_port_server42_stats" }}
      codec => json
      type => "kilda-server42-stats"
      tags => ["kilda-server42"]
  }
  tcp {
      port => {{ getv "/kilda_logging_port_tests" }}
      codec => json
      type => "kilda-tests"
      tags => ["kilda-tests"]
  }
}


filter {
  ruby {
    code => "
      event.to_hash.keys.each { |k| event[ k.sub('.','_') ] = event.remove(k) if k.include?'.' }
    "
  }

  ruby {
    code => "event.set('logstash_processed_at', Time.now());"
  }

  mutate {
      rename => { "logger_name" => "loggerName" }
      rename => { "thread_name" => "thread" }
  }

  mutate {
    convert => {
       "timeMillis" => "integer"
    }
    tag_on_failure => ["failed_to_convert_timeMillis"]
  }

  if "failed_to_convert_timeMillis" in [tags] {
    ruby {
      code => "event.set('timeMillis', (Time.now.to_f * 1000).to_i)"
    }
    mutate {
      add_field => { "generatedTimeMillis" => "1" }
    }
  }

  if "kilda-floodlight" in [tags] {
    grok {
      match => { "message" => "%{GREEDYDATA}value:%{GREEDYDATA:floodlight_message}" }
    }
    json {
      source => "floodlight_message"
      target => "floodlight_message_json"
      skip_on_invalid_json => true
    }

    mutate {
      remove_field => [ "floodlight_message" ]
    }

    if [floodlight_message_json][payload][timestamp] {
      ruby {
        code => "event.set('timeMillis', event.get('[floodlight_message_json][payload][timestamp]').to_i)"
      }
    }
  }

  if ![timeMillis] {
    if [instant][epochSecond] {
      if [instant][nanoOfSecond] {
        ruby {
          code => "event.set('timeMillis', (event.get('[instant][epochSecond]').to_i) * 1000 + (event.get('[instant][nanoOfSecond]') / 1000000).to_i)"
        }
      } else {
        ruby {
          code => "event.set('timeMillis', (event.get('[instant][epochSecond').to_i) * 1000)"
        }
      }
    } else {
      ruby {
        code => "event.set('timeMillis', (Time.now.to_f * 1000).to_i)"
      }
      mutate {
        add_field => { "generatedTimeMillis" => "1" }
      }
    }
  }
  mutate {
    rename => { "@timestamp" => "@timestamp_original" }
  }

  # if timeMillis defined and positive
  # build new timestamp based on timeMillis
  # else live timespamp as-is
  if [timeMillis] > 0 {
    date {
      match => [ "timeMillis", "UNIX_MS" ]
        target => "@timestamp"
        add_tag => "timestamp_changed"
    }
  } else {
    mutate {
      copy => { "@timestamp_original" => "@timestamp" }
    }
  }
}
output {
#  file {
#      flush_interval => 5
#      gzip => false
#      path => "/var/log/logstash-all-%{+YYYY.MM.dd}.log"
#  }
  if "dead_letter_queue" in [tags] {
    file {
      flush_interval => 5
      gzip => false
      path => "/var/log/logstash-debug-%{+YYYY.MM.dd}.log"
    }
  } else {
    elasticsearch {
      hosts => "{{ getv "/kilda_logging_elasticsearch_hosts" }}"
      index => "{{ getv "/kilda_logging_elasticsearch_logstash_index_pattern" }}"
    }
  }
}

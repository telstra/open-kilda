/* Copyright 2018 Telstra Open Source
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package org.openkilda.floodlight.converter;

import static org.junit.Assert.assertEquals;

import org.openkilda.messaging.info.rule.FlowApplyActions;
import org.openkilda.messaging.info.rule.FlowEntry;
import org.openkilda.messaging.info.rule.FlowInstructions;
import org.openkilda.messaging.info.rule.FlowSetFieldAction;
import org.openkilda.messaging.info.stats.FlowStatsData;
import org.openkilda.messaging.info.stats.FlowStatsEntry;
import org.openkilda.model.SwitchId;

import org.junit.Test;
import org.projectfloodlight.openflow.protocol.OFFactory;
import org.projectfloodlight.openflow.protocol.OFFlowModFlags;
import org.projectfloodlight.openflow.protocol.OFFlowStatsEntry;
import org.projectfloodlight.openflow.protocol.OFFlowStatsReply;
import org.projectfloodlight.openflow.protocol.action.OFAction;
import org.projectfloodlight.openflow.protocol.instruction.OFInstruction;
import org.projectfloodlight.openflow.protocol.match.Match;
import org.projectfloodlight.openflow.protocol.match.MatchField;
import org.projectfloodlight.openflow.protocol.ver13.OFFactoryVer13;
import org.projectfloodlight.openflow.types.EthType;
import org.projectfloodlight.openflow.types.IpProtocol;
import org.projectfloodlight.openflow.types.MacAddress;
import org.projectfloodlight.openflow.types.OFPort;
import org.projectfloodlight.openflow.types.OFVlanVidMatch;
import org.projectfloodlight.openflow.types.TableId;
import org.projectfloodlight.openflow.types.TransportPort;
import org.projectfloodlight.openflow.types.U64;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class OfFlowStatsMapperTest {

    public static final OFFactory factory = new OFFactoryVer13();
    public static final short tableId = 1;
    public static final long cookie = 2;
    public static final long packetCount = 3;
    public static final long byteCount = 4;
    public static final int durationSec = 5;
    public static final int durationNsec = 6;
    public static final int hardTimeout = 7;
    public static final int idleTimeout = 8;
    public static final int priority = 9;
    public static final OFVlanVidMatch vlanVid = OFVlanVidMatch.ofVlan(10);
    public static final MacAddress ethDst = MacAddress.of(11);
    public static final OFPort port = OFPort.of(12);
    public static final TransportPort udpDst = TransportPort.of(13);
    public static final TransportPort udpSrc = TransportPort.of(14);
    public static final SwitchId switchId = new SwitchId(15);
    public static final int xId = 16;
    public static final long meterId = 17;
    public static final IpProtocol ipProto = IpProtocol.UDP;
    public static final EthType ethType = EthType.IPv4;
    public static final OFFlowModFlags flag = OFFlowModFlags.SEND_FLOW_REM;

    @Test
    public void testToFlowStatsData() {
        OFFlowStatsEntry ofEntry = buildFlowStatsEntry();
        OFFlowStatsReply ofReply = factory.buildFlowStatsReply()
                .setXid(xId)
                .setEntries(Collections.singletonList(ofEntry))
                .build();

        FlowStatsData data = OfFlowStatsMapper.INSTANCE.toFlowStatsData(Collections.singletonList(ofReply), switchId);

        assertEquals(switchId, data.getSwitchId());

        assertEquals(1, data.getStats().size());
        FlowStatsEntry entry = data.getStats().get(0);

        assertEquals(tableId, entry.getTableId());
        assertEquals(cookie, entry.getCookie());
        assertEquals(packetCount, entry.getPacketCount());
        assertEquals(byteCount, entry.getByteCount());
    }

    @Test
    public void testFlowEntry() {
        OFFlowStatsEntry ofEntry = buildFlowStatsEntry();

        FlowEntry entry = OfFlowStatsMapper.INSTANCE.toFlowEntry(ofEntry);

        assertEquals(tableId, entry.getTableId());
        assertEquals(cookie, entry.getCookie());
        assertEquals(packetCount, entry.getPacketCount());
        assertEquals(byteCount, entry.getByteCount());
        assertEquals(durationSec, entry.getDurationSeconds());
        assertEquals(durationNsec, entry.getDurationNanoSeconds());
        assertEquals(hardTimeout, entry.getHardTimeout());
        assertEquals(idleTimeout, entry.getIdleTimeout());
        assertEquals(priority, entry.getPriority());

        assertEquals(String.valueOf(vlanVid.getVlan()), entry.getMatch().getVlanVid());
        assertEquals(ethType.toString(), entry.getMatch().getEthType());
        assertEquals(ethDst.toString(), entry.getMatch().getEthDst());
        assertEquals(port.toString(), entry.getMatch().getInPort());
        assertEquals(ipProto.toString(), entry.getMatch().getIpProto());
        assertEquals(udpSrc.toString(), entry.getMatch().getUdpSrc());
        assertEquals(udpDst.toString(), entry.getMatch().getUdpDst());

        FlowSetFieldAction flowSetFieldAction = new FlowSetFieldAction("eth_type", ethType.toString());
        FlowApplyActions applyActions = new FlowApplyActions(
                port.toString(), flowSetFieldAction, ethType.toString(), null, null);
        FlowInstructions instructions = new FlowInstructions(applyActions, null, meterId);
        assertEquals(instructions, entry.getInstructions());
    }

    private OFFlowStatsEntry buildFlowStatsEntry() {
        return factory.buildFlowStatsEntry()
                .setTableId(TableId.of(tableId))
                .setCookie(U64.of(cookie))
                .setPacketCount(U64.of(packetCount))
                .setByteCount(U64.of(byteCount))
                .setDurationSec(durationSec)
                .setDurationNsec(durationNsec)
                .setHardTimeout(hardTimeout)
                .setIdleTimeout(idleTimeout)
                .setPriority(priority)
                .setFlags(Collections.singleton(flag))
                .setMatch(buildMatch())
                .setInstructions(buildInstruction())
                .build();
    }

    private static Match buildMatch() {
        return factory.buildMatch()
                .setExact(MatchField.VLAN_VID, vlanVid)
                .setExact(MatchField.ETH_TYPE, ethType)
                .setExact(MatchField.ETH_DST, ethDst)
                .setExact(MatchField.IN_PORT, port)
                .setExact(MatchField.IP_PROTO, ipProto)
                .setExact(MatchField.UDP_DST, udpDst)
                .setExact(MatchField.UDP_SRC, udpSrc)
                .build();
    }

    private static List<OFInstruction> buildInstruction() {
        List<OFAction> actions = new ArrayList<>();

        actions.add(factory.actions().pushVlan(ethType));
        actions.add(factory.actions().output(port, 0));
        actions.add(factory.actions().setField(factory.oxms().ethType(ethType)));

        List<OFInstruction> instructions = new ArrayList<>();

        instructions.add(factory.instructions().applyActions(actions));
        instructions.add(factory.instructions().buildMeter().setMeterId(meterId).build());

        return instructions;
    }
}
